# TDD

- 컨트롤러 및 이하 레이어의 로직을 작성하기도 전에 먼저 테스트 클래스부터 생성하여 작성을 시작

# 테스트 클래스 작성

```java
//@RunWith(SpringRunner.class)
@ExtendWith(SpringExtension.class)
@WebMvcTest
class TestClass{
	@Autowird
	MockMvc mockMvc;
}
```

## 테스트 클래스 선언

- JUnit4는 `@RunWith(SpringRunner.class)` JUnit5에서는 `@ExtendWith(SpringExtension.class)`로  테스트 클래스를 선언한다

## @WebMvcTest

- 웹MVC 및 테스트 관련 빈들을 생성해준다
- 웹MVC, 테스트와 관련된 빈들만 생성해주므로 좀 더 효율적이고 빠를수 있다.
- 계층별로 Slice하여 빈을 생성한다고 슬라이싱 테스트라고 한다.
- 웹MVC와 관련된 인스턴스만으로도 디스패처 서블릿, 데이터 핸들러, 데이터 매퍼 등등 많은것들이 개입되어 있으므로 단위테스트라고는 할 수 없다.

## MockMvc

- Mocking된 DispatcherServlet을 제공해줌
- 스프링 MVC 테스트의 핵심 클래스이다
- 웹서버를 띄우지 않고도 MVC가 요청을 처리하는 과정을 확인할 수 있으므로, 컨트롤러의 테스트에 많이 쓰인다

# 테스트 메소드 작성

```java
@Test
    void createEvent() throws Exception {
        mockMvc.perform(post("/api/events")
                .contentType(MediaType.APPLICATION_PROBLEM_JSON_UTF8)
                .accept(MediaTypes.HAL_JSON))
                .andExpect(status().isCreated());
    }
```

## @Test

- 메소드에 @Test 어노테이션을 붙여 테스트 메소드임을 선언

## MockMvc.perform()

- 컨트롤러에 요청을 날릴땐 mockMvc의 perform메소드를 사용한다
- perform()의 인자로는 MockHttpServletRequestBuilder 타입의 요청정보를 작성한다
    - 요청정보는 MockMvcRequestBuilder 혹은 RestDocumentationRequestBuilders의 메소드들을 사용한다

## ResultActions.andExpect()

- 요청결과에 대한 테스트를 수행할땐 ResultActions의 andExpect() 메소드를 사용한다